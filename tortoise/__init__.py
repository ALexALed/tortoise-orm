import asyncio
import importlib
import inspect
import json
import logging
import os
import warnings
from contextvars import ContextVar
from typing import Any, Coroutine, Dict, List, Optional, Type, Union

from tortoise.apps import Apps
from tortoise.backends.base.client import BaseDBAsyncClient
from tortoise.backends.base.config_generator import expand_db_url, generate_config
from tortoise.connection_repository import ConnectionRepository
from tortoise.exceptions import ConfigurationError
from tortoise.fields import Field
from tortoise.fields.relational import (
    BackwardFKRelation,
    BackwardOneToOneRelation,
    ForeignKeyFieldInstance,
    ManyToManyFieldInstance,
    OneToOneFieldInstance,
)
from tortoise.filters import get_m2m_filters
from tortoise.models import Model
from tortoise.queryset import QuerySet
from tortoise.transactions import current_transaction_map
from tortoise.utils import generate_schema_for_client

logger = logging.getLogger("tortoise")


class Tortoise:
    apps: Optional[Apps] = None
    _connection_repository: ConnectionRepository = ConnectionRepository()
    _inited: bool = False

    @classmethod
    def get_connection(cls, connection_name: str) -> BaseDBAsyncClient:
        """
        Returns the connection by name.

        :raises KeyError: If connection name does not exist.
        """
        return cls._connection_repository[connection_name]

    @classmethod
    def describe_field(cls, name: str, field: Field, serializable: bool = True):
        """
                Describe given field assuming given name
        :param name:
            Name of field on model

        :param field:
            Field instance

        :param serializable:
            ``False`` if you want raw python objects,
            ``True`` for JSON-serialisable data. (Defaults to ``True``)

        :return: return dict is specified as follows
        (This assumes ``serializable=True``, which is the default):

        ..code - block:: python3

        {
            "name": str  # Field name
            "field_type": str  # Field type
            "db_column": str  # Name of DB column
            #  Optional: Only for pk/data fields
            "raw_field": str  # Name of raw field of the Foreign Key
            #  Optional: Only for Foreign Keys
            "db_field_types": dict  # DB Field types for default and DB overrides
            "python_type": str  # Python type
            "generated": bool  # Is the field generated by the DB?
            "nullable": bool  # Is the column nullable?
            "unique": bool  # Is the field unique?
            "indexed": bool  # Is the field indexed?
            "default": ...  # The default value (coerced to int/float/str/bool/null)
            "description": str  # Description of the field (nullable)
            "docstring": str  # Field docstring (nullable)
        }
        """

        def _type_name(typ: Type) -> str:
            if typ.__module__ == "builtins":
                return typ.__name__
            if typ.__module__ == "typing":
                return str(typ).replace("typing.", "")
            return f"{typ.__module__}.{typ.__name__}"

        def type_name(typ: Any) -> Union[str, List[str]]:
            try:
                if issubclass(typ, Model) and cls.apps:
                    return cls.apps.get_model_reference(typ)
            except TypeError:
                pass
            try:
                return _type_name(typ)
            except AttributeError:
                try:
                    return [_type_name(_typ) for _typ in typ]  # pragma: nobranch
                except TypeError:
                    return str(typ)

        def default_name(default: Any) -> Optional[Union[int, float, str, bool]]:
            if isinstance(default, (int, float, str, bool, type(None))):
                return default
            if callable(default):
                return f"<function {default.__module__}.{default.__name__}>"
            return str(default)

        field_type = getattr(field, "model_class", field.field_type)
        desc = {
            "name": name,
            "field_type": field.__class__.__name__ if serializable else field.__class__,
            "db_column": field.source_field or name,
            "raw_field": None,
            "db_field_types": field.get_db_field_types(),
            "python_type": type_name(field_type) if serializable else field_type,
            "generated": field.generated,
            "nullable": field.null,
            "unique": field.unique,
            "indexed": field.index or field.unique,
            "default": default_name(field.default) if serializable else field.default,
            "description": field.description,
            "docstring": field.docstring,
            "constraints": field.constraints,
        }

        # Delete db fields for non-db fields
        if not desc["db_field_types"]:
            del desc["db_field_types"]

        # Foreign Keys have
        if isinstance(field, (ForeignKeyFieldInstance, OneToOneFieldInstance)):
            del desc["db_column"]
            desc["raw_field"] = field.source_field
        else:
            del desc["raw_field"]

        # These fields are entierly "virtual", so no direct DB representation
        if isinstance(
            field, (ManyToManyFieldInstance, BackwardFKRelation, BackwardOneToOneRelation,),
        ):
            del desc["db_column"]

        return desc

    @classmethod
    def describe_field_for_model(
        cls, model: Type[Model], name: str, serializable: bool = True
    ) -> dict:
        """

        :param model:
            Instance of model

        :param name:
            Name of field on model

        :param serializable:
            ``False`` if you want raw python objects,
            ``True`` for JSON-serialisable data. (Defaults to ``True``)

        :return:
            Dict as per Tortoise.describe_field
        """

        field = model._meta.fields_map[name]
        return cls.describe_field(name, field, serializable)

    @classmethod
    def describe_model(cls, model: Type[Model], serializable: bool = True) -> dict:
        """
        Describes given model

        :param model:
            The Model to describe

        :param serializable:
            ``False`` if you want raw python objects,
            ``True`` for JSON-serialisable data. (Defaults to ``True``)

        :return:
            A dictionary containing the model description.

            The base dict has a fixed set of keys that reference a list of fields
            (or a single field in the case of the primary key):

            .. code-block:: python3

                {
                    "name":                 str     # Qualified model name
                    "app":                  str     # 'App' namespace
                    "table":                str     # DB table name
                    "abstract":             bool    # Is the model Abstract?
                    "description":          str     # Description of table (nullable)
                    "docstring":            str     # Model docstring (nullable)
                    "unique_together":      [...]   # List of List containing field names that
                                                    #  are unique together
                    "options":              {...}   # Dict with parameters passed to Meta
                                                    #   class in Model
                    "pk_field":             {...}   # Primary key field
                    "data_fields":          [...]   # Data fields
                    "fk_fields":            [...]   # Foreign Key fields FROM this model
                    "backward_fk_fields":   [...]   # Foreign Key fields TO this model
                    "o2o_fields":           [...]   # OneToOne fields FROM this model
                    "backward_o2o_fields":  [...]   # OneToOne fields TO this model
                    "m2m_fields":           [...]   # Many-to-Many fields
                }

            For fields schema description refer to Tortoise.describe_field(...)

            When ``serializable=False`` is specified some fields are not coerced to valid
            JSON types. The changes are:

            .. code-block:: python3

                {
                    "field_type":   Field   # The Field class used
                    "python_type":  Type    # The actual Python type
                    "default":      ...     # The default value as native type OR a callable
                }

        :raises ConfigurationError: When ``.init()`` has not been called.
        """
        if not cls.apps:
            raise ConfigurationError("describe_model can be called only after init")

        return {
            "name": cls.apps.get_model_reference(model),
            "app": model._meta.app,
            "table": model._meta.table,
            "abstract": model._meta.abstract,
            "description": model._meta.table_description or None,
            "docstring": inspect.cleandoc(model.__doc__ or "") or None,
            "unique_together": model._meta.unique_together or [],
            "pk_field": describe_field(model._meta.pk_attr),
            "data_fields": [
                cls.describe_field_for_model(model, name, serializable)
                for name in model._meta.fields_map.keys()
                if name != model._meta.pk_attr
                and name in (model._meta.fields - model._meta.fetch_fields)
            ],
            "fk_fields": [
                cls.describe_field_for_model(model, name, serializable)
                for name in model._meta.fields_map.keys()
                if name in model._meta.fk_fields
            ],
            "backward_fk_fields": [
                cls.describe_field_for_model(model, name, serializable)
                for name in model._meta.fields_map.keys()
                if name in model._meta.backward_fk_fields
            ],
            "o2o_fields": [
                cls.describe_field_for_model(model, name, serializable)
                for name in model._meta.fields_map.keys()
                if name in model._meta.o2o_fields
            ],
            "backward_o2o_fields": [
                cls.describe_field_for_model(model, name, serializable)
                for name in model._meta.fields_map.keys()
                if name in model._meta.backward_o2o_fields
            ],
            "m2m_fields": [
                cls.describe_field_for_model(model, name, serializable)
                for name in model._meta.fields_map.keys()
                if name in model._meta.m2m_fields
            ],
        }

    @classmethod
    def describe_models(
        cls, models: Optional[List[Type[Model]]] = None, serializable: bool = True
    ) -> Dict[str, dict]:
        """
        Describes the given list of models or ALL registered models.

        :param models:
            List of models to describe, if not provided then describes ALL registered models

        :param serializable:
            ``False`` if you want raw python objects,
            ``True`` for JSON-serializable data. (Defaults to ``True``)

        :return:
            A dictionary containing the model qualifier as key,
            and the same output as ``describe_model(...)`` as value:

            .. code-block:: python3

                {
                    "models.User": {...},
                    "models.Permission": {...}
                }
        """

        if not models:
            models = []
            for app in cls.apps.values():
                for model in app.values():
                    models.append(model)

        return {
            f"{model._meta.app}.{model.__name__}": cls.describe_model(model, serializable)
            for model in models
        }

    @classmethod
    def _discover_client_class(cls, engine: str) -> BaseDBAsyncClient:
        # Let exception bubble up for transparency
        engine_module = importlib.import_module(engine)

        try:
            client_class = engine_module.client_class  # type: ignore
        except AttributeError:
            raise ConfigurationError(f'Backend for engine "{engine}" does not implement db client')
        return client_class

    @classmethod
    async def _init_connections(cls, connections_config: dict, create_db: bool) -> None:
        for name, info in connections_config.items():
            if isinstance(info, str):
                info = expand_db_url(info)
            client_class = cls._discover_client_class(info.get("engine"))
            db_params = info["credentials"].copy()
            db_params.update({"connection_name": name})
            connection = client_class(**db_params)  # type: ignore
            if create_db:
                await connection.db_create()
            await connection.create_connection(with_db=True)
            cls._connection_repository.register(name, connection)
            current_transaction_map[name] = ContextVar(name, default=connection)

    @classmethod
    def _get_config_from_config_file(cls, config_file: str) -> dict:
        _, extension = os.path.splitext(config_file)
        if extension in (".yml", ".yaml"):
            import yaml  # pylint: disable=C0415

            with open(config_file, "r") as f:
                config = yaml.safe_load(f)
        elif extension == ".json":
            with open(config_file, "r") as f:
                config = json.load(f)
        else:
            raise ConfigurationError(
                f"Unknown config extension {extension}, only .yml and .json are supported"
            )
        return config

    @classmethod
    def init_app(cls, label: str, model_paths: List[str], _init_relations: bool = True):
        if not cls.apps:
            cls.apps = Apps(config={}, connections=cls._connection_repository)

        cls.apps.init_app(label, model_paths, _init_relations=_init_relations)

    @classmethod
    def init_models(
        cls, models_paths: List[str], app_label: str, _init_relations: bool = True
    ) -> None:
        warnings.warn(
            "init_models() is deprecated, use init_app() instead", DeprecationWarning, stacklevel=2,
        )
        return cls.init_app(app_label, models_paths, _init_relations=_init_relations)

    @classmethod
    async def init(
        cls,
        config: Optional[dict] = None,
        config_file: Optional[str] = None,
        _create_db: bool = False,
        db_url: Optional[str] = None,
        modules: Optional[Dict[str, List[str]]] = None,
    ) -> None:
        """
        Sets up Tortoise-ORM.

        You can configure using only one of ``config``, ``config_file``
        and ``(db_url, modules)``.

        :param config:
            Dict containing config:

            .. admonition:: Example

                .. code-block:: python3

                    {
                        'connections': {
                            # Dict format for connection
                            'default': {
                                'engine': 'tortoise.backends.asyncpg',
                                'credentials': {
                                    'host': 'localhost',
                                    'port': '5432',
                                    'user': 'tortoise',
                                    'password': 'qwerty123',
                                    'database': 'test',
                                }
                            },
                            # Using a DB_URL string
                            'default': 'postgres://postgres:qwerty123@localhost:5432/events'
                        },
                        'apps': {
                            'models': {
                                'models': ['__main__'],
                                # If no default_connection specified, defaults to 'default'
                                'default_connection': 'default',
                            }
                        }
                    }

        :param config_file:
            Path to .json or .yml (if PyYAML installed) file containing config with
            same format as above.
        :param db_url:
            Use a DB_URL string. See :ref:`db_url`
        :param modules:
            Dictionary of ``key``: [``list_of_modules``] that defined "apps" and modules that
            should be discovered for models.
        :param _create_db:
            If ``True`` tries to create database for specified connections,
            could be used for testing purposes.

        :raises ConfigurationError: For any configuration error
        """
        if cls._inited:
            await cls.close_connections()
            await cls._reset_apps()

        if int(bool(config) + bool(config_file) + bool(db_url)) != 1:
            raise ConfigurationError(
                'You should init either from "config", "config_file" or "db_url"'
            )

        if config_file:
            config = cls._get_config_from_config_file(config_file)

        if db_url:
            if not modules:
                raise ConfigurationError('You must specify "db_url" and "modules" together')
            config = generate_config(db_url, modules)

        try:
            connections_config = config["connections"]  # type: ignore
        except KeyError:
            raise ConfigurationError('Config must define "connections" section')

        try:
            apps_config = config["apps"]  # type: ignore
        except KeyError:
            raise ConfigurationError('Config must define "apps" section')

        logger.info(
            "Tortoise-ORM startup\n    connections: %s\n    apps: %s",
            str(connections_config),
            str(apps_config),
        )

        await cls._init_connections(connections_config, _create_db)
        cls.apps = Apps(apps_config, cls._connection_repository)

        cls._inited = True

    @classmethod
    async def close_connections(cls) -> None:
        """
        Close all connections cleanly.

        It is required for this to be called on exit,
        else your event loop may never complete
        as it is waiting for the connections to die.
        """
        for connection in cls._connection_repository.get_connections():
            await connection.close()
        cls._connection_repository = ConnectionRepository()
        logger.info("Tortoise-ORM shutdown")

    @classmethod
    async def _reset_apps(cls) -> None:
        if not cls.apps:
            return

        for model in cls.apps.get_models_iterable():
            model._meta.default_connection = None

        cls.apps = None
        current_transaction_map.clear()

    @classmethod
    async def generate_schemas(cls, safe: bool = True) -> None:
        """
        Generate schemas according to models provided to ``.init()`` method.
        Will fail if schemas already exists, so it's not recommended to be used as part
        of application workflow

        :param safe: When set to true, creates the table only when it does not already exist.

        :raises ConfigurationError: When ``.init()`` has not been called.
        """
        if not cls._inited:
            raise ConfigurationError("You have to call .init() first before generating schemas")
        for connection in cls._connection_repository.get_connections():
            await generate_schema_for_client(connection, safe)

    @classmethod
    async def _drop_databases(cls) -> None:
        """
        Tries to drop all databases provided in config passed to ``.init()`` method.
        Normally should be used only for testing purposes.

        :raises ConfigurationError: When ``.init()`` has not been called.
        """
        if not cls._inited:
            raise ConfigurationError("You have to call .init() first before deleting schemas")
        for connection in cls._connection_repository.get_connections():
            await connection.close()
            await connection.db_delete()
        cls._connection_repository = ConnectionRepository()
        await cls._reset_apps()


def run_async(coro: Coroutine) -> None:
    """
    Simple async runner that cleans up DB connections on exit.
    This is meant for simple scripts.

    Usage::

        from tortoise import Tortoise, run_async

        async def do_stuff():
            await Tortoise.init(
                db_url='sqlite://db.sqlite3',
                models={'models': ['app.models']}
            )

            ...

        run_async(do_stuff())
    """
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(coro)
    finally:
        loop.run_until_complete(Tortoise.close_connections())


__version__ = "0.16.4"
